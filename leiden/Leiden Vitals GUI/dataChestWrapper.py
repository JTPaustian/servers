# Copyright (C) 2016 Noah Meltzer
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Utilities libraries.


"""
### BEGIN NODE INFO
[info]
name = NGui class
version = 1.0.1
description = Handles datalogging using DataChest

### END NODE INFO
"""

from PyQt4 import QtCore, QtGui
import os
from dataChest import *
import sys
from dateStamp import *
import datetime
import threading
import numpy

class dataChestWrapper:
	'''The dataChestWrapper class handles all datalogging.'''
	def __init__(self, devices):
		'''Initialize the datalogger, if datasets already exist, use them. Otherwise create new ones.'''
		now = datetime.datetime.now()
		# Create a devices reference that can be accessed outside of this scope.
		self.devices = devices
		# This array will hold all dataChest data sets.
		self.dataSets = []
		# For all devices
		for i in range(0, len(self.devices)):
			# Generate a title for the dataset. NOTE: if the title of the device is changed in the devices constructor
			# in the main class, then a different data set will be created. This is because datasets are stored
			# using the name of the device, which is what the program looks for when checking if there are
			# data files that already exist.
			title = str(self.devices[i].getFrame().getTitle()).replace(" ", "")
			# Append a new dataChest object to the end of the datasets array.
			self.dataSets.append(dataChest(str(now.year)))
			# Datasets are stored in the folder 'DATA_CHEST_ROOT\year\month\'
			# Try to access the current month's folder, if it does not exist, make it.
			try:
				self.dataSets[i].cd(str(now.month))
			except:
				self.dataSets[i].mkdir(str(now.month))
				self.dataSets[i].cd(str(now.month))
		
			# Look at the names of all existing datasets and check if the name contains
			# the title of the current device. 
			existingFiles = self.dataSets[i].ls()
			# Name of the parameter. i.e. if the device is the 'Temperature Monitor' the parameter is 'temperature'
			paramName = None
			# foundit becomes true if a dataset file already exists
			foundit = False
			# Go through all existing dataset files
			for y in range(0, len(existingFiles[0])):
				# If the name of the file contains the (persistant) title generated by the code, open that dataset and use it.
				if(title in existingFiles[0][y]):
					self.dataSets[i].openDataset(existingFiles[0][y], modify = True)
					foundit = True
			if(foundit):
				print("Previously existing data set found for "+title)
			# If the dataset does not already exist, we must create it.
			else:
				# Arrays to hold any variables
				depvars = []
				indepvars = []
				# Loop through all parameters in the device
				for y in range (0, len(self.devices[i].getFrame().getNicknames())):
					# If the name of the parameter has not been defined as None in the constructor, then we want to log it.
					if(self.devices[i].getFrame().getNicknames()[y] is not None):
						# The name of the parameter in the dataset is the same name displayed on the GUI except without spaces
						paramName = str(self.devices[i].getFrame().getNicknames()[y])
						# Create the tuple that defines the parameter.
						tup = (paramName, [1], "float64", str(self.devices[i].getFrame().getUnits()))
						# Add it to the array of dependent variables
						depvars.append(tup)
				dStamp = dateStamp()
				# Time is the only independent variable
				indepvars.append(("time", [1], "utc_datetime", "s"))
				# The vars variable holds ALL variables
				vars = []
				vars.extend(indepvars)
				vars.extend(depvars)
				# Construct the data set
				self.dataSets[i].createDataset(title,
										indepvars,
										depvars)
				# The datawidth parameter says how many variables (independent and dependent) make up the dataset.
				# DataWidth is used internally only.
				self.dataSets[i].addParameter("DataWidth", len(vars))
		# Each the datalogging is handled in its own thread
		self.deviceThread = threading.Thread(target = self.save, args=[])
		# If the main thread stops, stop the child thread
		self.deviceThread.daemon = True
		# Start the thread
		self.deviceThread.start()
		
	def save(self):
		'''Stores the data'''
		# For all datasets
		for i in range(0, len(self.dataSets)):
			depvars = []
			indepvars = []
			vars = []
			readings = []
			for y in range(0, len(self.devices[i].getFrame().getNicknames())):
				if(self.devices[i].getFrame().getNicknames()[y] is not None):
					if(self.devices[i].getFrame().getReadings() is not None):
						readings.append(self.devices[i].getFrame().getReadings()[y])
					else:
						readings.append(np.nan)
			dStamp = dateStamp()
			if(readings is not None):
				indepvars.append(dStamp.utcNowFloat())
				depvars.extend(readings)
				vars.extend(indepvars)
				vars.extend(depvars)
				self.dataSets[i].addData([vars])
			else:
				vars.append(dStamp.utcNowFloat())
				for y in range(1, self.dataSets[i].getParameter("DataWidth")):
					vars.append(np.nan)
				self.dataSets[i].addData([vars])
			
		threading.Timer(1, self.save).start()